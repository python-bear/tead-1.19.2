package net.pythonbear.tead.item.sickle;

import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.entity.ExperienceOrbEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.BlockSoundGroup;
import net.minecraft.sound.SoundCategory;
import net.minecraft.state.property.IntProperty;
import net.minecraft.tag.BlockTags;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockBox;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.registry.Registry;
import net.minecraft.util.registry.RegistryKey;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.GameRules;
import net.minecraft.world.World;
import net.pythonbear.tead.Tead;
import net.pythonbear.tead.item.SickleItem;

import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Random;

public final class UseBlockHandler {
    public static ActionResult handle(PlayerEntity player, World world, Hand hand, BlockHitResult result) {
        ActionResult actionResult = ActionResult.PASS;

        assert player != null;
        if (!player.isSpectator()) {
            BlockPos blockPos = result.getBlockPos();
            BlockState blockState = world.getBlockState(blockPos);
            if (hand == Hand.MAIN_HAND && canHarvest(world, blockState, blockPos, player, hand, true) &&
                    player.getStackInHand(Hand.MAIN_HAND).getItem() instanceof SickleItem) {
                try {
                    IntProperty cropAge = SickleHarvesting.getAge(blockState);
                    if (SickleHarvesting.isMature(blockState, cropAge)) {
                        actionResult = ActionResult.SUCCESS;
                        if (!world.isClient()) {
                            harvest((ServerWorld) world, cropAge, blockState, blockPos, result.getSide(), result,
                                    (ServerPlayerEntity) player, hand);

                            BlockState state = world.getBlockState(blockPos);
                            if (canHarvest(world, state, blockPos, player, hand, false)) {
                                IntProperty age = SickleHarvesting.getAge(state);
                                if (SickleHarvesting.isMature(state, age)) {
                                    harvest((ServerWorld) world, age, state, result.getBlockPos(), result.getSide(),
                                            null, (ServerPlayerEntity) player, hand);
                                }
                            }
                        }
                    }
                } catch (NullPointerException | NoSuchElementException | ClassCastException e) {
                    Tead.LOGGER.debug("Exception generated by block at [" + blockPos.toShortString() + "]");
                    Tead.LOGGER.debug("This is a non blocking error, but can result in incorrect behavior for mod "
                            + Tead.MOD_ID);
                    Tead.LOGGER.debug("Most probably the cause of this issue was that a non-crop ID was added in " +
                            "the configuration and its age property could not be retrieved, see stack trace for " +
                            "more details", e);
                }
            }
        }
        return actionResult;
    }
    private static boolean canHarvest(World world, BlockState blockState, BlockPos blockPos, PlayerEntity player,
                                      Hand hand, boolean first) {
        return SickleHarvesting.isCrop(blockState.getBlock()) && player.canHarvest(blockState) &&
                SickleHarvestEvents.HARVEST_CHECK.invoker().check(world, blockState, blockPos, player, hand, first,
                        new SickleHarvestEvents.HarvestCheckEvent());
    }
    private static void harvest(ServerWorld world, IntProperty age, BlockState blockState, BlockPos blockPos,
                                Direction face, BlockHitResult hitResult, ServerPlayerEntity player, Hand hand) {
        SickleHarvestEvents.BEFORE_HARVEST.invoker().beforeHarvest(world, blockState, blockPos, face, hitResult, player,
                hand, hitResult != null);
        BlockPos basePos = getBasePos(world, blockState.getBlock(), blockPos);
        grantExp(world, basePos);
        damageSickle(player, hand);
        updateCrop(world, age, blockState.getBlock(), basePos, player, dropResources(world,
                world.getBlockState(basePos), basePos, face, hitResult, player, hand));
        playSound(world, blockState, blockPos);
        SickleHarvestEvents.AFTER_HARVEST.invoker().afterHarvest(world, blockState, blockPos, face, hitResult, player,
                hand, hitResult != null);
    }
    private static void playSound(ServerWorld world, BlockState blockState, BlockPos blockPos) {
        BlockSoundGroup soundGroup = blockState.getBlock().getSoundGroup(blockState);
        world.playSound(null, blockPos, soundGroup.getBreakSound(), SoundCategory.BLOCKS, soundGroup.getVolume(),
                soundGroup.getPitch());
    }
    private static void updateCrop(ServerWorld world, IntProperty age, Block block, BlockPos basePos,
                                   ServerPlayerEntity player, boolean customDrops) {
        world.setBlockState(basePos, world.getBlockState(basePos).with(age, 0));
        if (world.getBlockState(basePos).isIn(BlockTags.CROPS) && world.getBlockState(basePos.up()).isOf(block) &&
                !isTallButSeparate(block)) {
            world.breakBlock(basePos.up(), !customDrops, player);
        }
    }
    private static BlockPos getBasePos(ServerWorld world, Block block, BlockPos blockPos) {
        BlockPos basePos;
        for (basePos = blockPos; world.getBlockState(blockPos).isIn(BlockTags.CROPS) && !isTallButSeparate(block) &&
                world.getBlockState(basePos.down()).isOf(block); basePos = basePos.down());
        return basePos;
    }
    private static void grantExp(ServerWorld world, BlockPos pos) {
        if (world.getGameRules().getBoolean(GameRules.DO_TILE_DROPS)) {
            Random random = new Random();
            int experienceAmount = random.nextInt(2) + 1;

            ExperienceOrbEntity.spawn(world, Vec3d.ofCenter(pos), experienceAmount);
        }
    }
    private static void damageSickle(ServerPlayerEntity player, Hand hand) {
        if (!player.isCreative()) {
            Random random = new Random();
            int randomNumber = random.nextInt(2) + 1;

            player.getStackInHand(hand).damage(randomNumber, player,
                    playerEntity -> playerEntity.sendToolBreakStatus(hand));
        }
    }
    private static boolean dropResources(ServerWorld world, BlockState blockState, BlockPos blockPos, Direction face,
                                         BlockHitResult hitResult, ServerPlayerEntity player, Hand hand) {
        SickleHarvestEvents.HarvestDropsEvent event = new SickleHarvestEvents.HarvestDropsEvent(world, blockState,
                blockPos, player, hand);
        for (ItemStack stack : SickleHarvestEvents.HARVEST_DROPS.invoker().getDrops(world, blockState, blockPos, face,
                hitResult, player, hand, hitResult != null, event)) {
            if (blockState.getCollisionShape(world, blockPos) != VoxelShapes.empty()) {
                Block.dropStack(world, blockPos, face, stack);
            } else {
                Block.dropStack(world, blockPos, stack);
            }
        }
        return event.haveDropsChanged();
    }
    private static boolean isTallButSeparate(Block block) {
        Optional<RegistryKey<Block>> key = Registry.BLOCK.getKey(block);
        return key.map(blockRegistryKey -> blockRegistryKey.getValue().toString().equals("farmersdelight:tomatoes"))
                .orElse(false);
    }
    private static BlockBox expandHorizontally(BlockBox box, int distance) {
        return new BlockBox(box.getMinX() - distance, box.getMinY(), box.getMinZ() - distance,
                box.getMaxX() + distance, box.getMaxY(), box.getMaxZ() + distance);
    }
}